@using GuitarChords.Services
@using GuitarChords.Models
@using MusicTheory
@inject GuitarChordService ChordService

<div class="circle-of-fifths-container" style="max-width: @(Size)px; margin: 0 auto;">
    <svg viewBox="0 0 400 400"
         width="100%"
         height="100%"
         role="img"
         aria-labelledby="cof-title cof-desc"
         @onkeydown="HandleKeyDown"
         tabindex="0">
        <title id="cof-title">Circle of Fifths</title>
        <desc id="cof-desc">Interactive circle showing the relationship between musical keys. Major keys on the outer ring, relative minor keys on the inner ring.</desc>

        <defs>
            <linearGradient id="cof-major-gradient" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" style="stop-color:#7c3aed;stop-opacity:0.2" />
                <stop offset="100%" style="stop-color:#7c3aed;stop-opacity:0.4" />
            </linearGradient>
            <linearGradient id="cof-minor-gradient" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" style="stop-color:#059669;stop-opacity:0.2" />
                <stop offset="100%" style="stop-color:#059669;stop-opacity:0.4" />
            </linearGradient>
            <filter id="cof-shadow" x="-20%" y="-20%" width="140%" height="140%">
                <feDropShadow dx="0" dy="2" stdDeviation="3" flood-opacity="0.3"/>
            </filter>
        </defs>

        @* Background circles *@
        <circle cx="200" cy="200" r="190" fill="url(#cof-major-gradient)" stroke="#7c3aed" stroke-width="2"/>
        <circle cx="200" cy="200" r="130" fill="url(#cof-minor-gradient)" stroke="#059669" stroke-width="2"/>
        <circle cx="200" cy="200" r="70" fill="#1e1e2e" stroke="#4a4a5a" stroke-width="1"/>

        @* Major keys (outer ring) *@
        @for (int i = 0; i < 12; i++)
        {
            var key = MajorKeys[i];
            var angle = -90 + (i * 30);
            var radians = angle * Math.PI / 180;
            var x = 200 + 160 * Math.Cos(radians);
            var y = 200 + 160 * Math.Sin(radians);
            var isSelected = SelectedKey == key;
            var isRelated = IsRelatedKey(key);

            <g class="key-segment @(isSelected ? "selected" : "") @(isRelated ? "related" : "")"
               @onclick="@(() => SelectKey(key))"
               @onmouseenter="@(() => HoverKey(key))"
               @onmouseleave="@(() => HoverKey(null))"
               style="cursor: pointer;"
               role="button"
               aria-label="@key major key"
               aria-pressed="@isSelected.ToString().ToLower()">

                @* Key segment arc *@
                <path d="@GetArcPath(i, 130, 190)"
                      fill="@(isSelected ? "#7c3aed" : (isRelated ? "#a78bfa" : "transparent"))"
                      stroke="@(isSelected ? "#7c3aed" : "#4a4a5a")"
                      stroke-width="1"
                      opacity="@(isSelected ? "0.8" : (isRelated ? "0.5" : "0.2"))"/>

                @* Key label *@
                <text x="@x" y="@y"
                      text-anchor="middle"
                      dominant-baseline="central"
                      fill="@(isSelected ? "white" : (isRelated ? "#c4b5fd" : "#e0e0e0"))"
                      font-size="@(isSelected ? "18" : "16")"
                      font-weight="@(isSelected ? "bold" : "normal")"
                      filter="@(isSelected ? "url(#cof-shadow)" : "")">
                    @key
                </text>
            </g>
        }

        @* Minor keys (inner ring) *@
        @for (int i = 0; i < 12; i++)
        {
            var key = MinorKeys[i];
            var angle = -90 + (i * 30);
            var radians = angle * Math.PI / 180;
            var x = 200 + 100 * Math.Cos(radians);
            var y = 200 + 100 * Math.Sin(radians);
            var isSelected = SelectedKey == key;
            var isRelative = IsRelativeMinor(key);

            <g class="key-segment minor @(isSelected ? "selected" : "") @(isRelative ? "relative" : "")"
               @onclick="@(() => SelectKey(key))"
               @onmouseenter="@(() => HoverKey(key))"
               @onmouseleave="@(() => HoverKey(null))"
               style="cursor: pointer;"
               role="button"
               aria-label="@key minor key"
               aria-pressed="@isSelected.ToString().ToLower()">

                @* Key segment arc *@
                <path d="@GetArcPath(i, 70, 130)"
                      fill="@(isSelected ? "#059669" : (isRelative ? "#34d399" : "transparent"))"
                      stroke="@(isSelected ? "#059669" : "#3a3a4a")"
                      stroke-width="1"
                      opacity="@(isSelected ? "0.8" : (isRelative ? "0.5" : "0.2"))"/>

                @* Key label *@
                <text x="@x" y="@y"
                      text-anchor="middle"
                      dominant-baseline="central"
                      fill="@(isSelected ? "white" : (isRelative ? "#6ee7b7" : "#a0a0a0"))"
                      font-size="@(isSelected ? "14" : "12")"
                      font-weight="@(isSelected ? "bold" : "normal")">
                    @key
                </text>
            </g>
        }

        @* Center info *@
        <g class="center-info">
            @if (!string.IsNullOrEmpty(SelectedKey))
            {
                @((MarkupString)$"<text x=\"200\" y=\"190\" text-anchor=\"middle\" fill=\"#e0e0e0\" font-size=\"12\">Selected Key</text>")
                @((MarkupString)$"<text x=\"200\" y=\"210\" text-anchor=\"middle\" fill=\"white\" font-size=\"18\" font-weight=\"bold\">{SelectedKey}</text>")
            }
            else
            {
                @((MarkupString)"<text x=\"200\" y=\"195\" text-anchor=\"middle\" fill=\"#a0a0a0\" font-size=\"11\">Click a key</text>")
                @((MarkupString)"<text x=\"200\" y=\"210\" text-anchor=\"middle\" fill=\"#a0a0a0\" font-size=\"11\">to explore</text>")
            }
        </g>
    </svg>
</div>

@code {
    [Parameter]
    public int Size { get; set; } = 400;

    [Parameter]
    public string? SelectedKey { get; set; }

    [Parameter]
    public EventCallback<string?> SelectedKeyChanged { get; set; }

    [Parameter]
    public EventCallback<string> OnKeySelected { get; set; }

    [Parameter]
    public EventCallback<GuitarChord> OnChordSelected { get; set; }

    private string? _hoveredKey;
    private int _focusedIndex = 0;

    private static readonly string[] MajorKeys = { "C", "G", "D", "A", "E", "B", "F#", "Db", "Ab", "Eb", "Bb", "F" };
    private static readonly string[] MinorKeys = { "Am", "Em", "Bm", "F#m", "C#m", "G#m", "D#m", "Bbm", "Fm", "Cm", "Gm", "Dm" };

    private async Task SelectKey(string key)
    {
        SelectedKey = key;
        await SelectedKeyChanged.InvokeAsync(key);
        await OnKeySelected.InvokeAsync(key);

        // Try to get the chord and notify
        var chord = ChordService.GetChord(key);
        if (chord != null)
        {
            await OnChordSelected.InvokeAsync(chord);
        }
    }

    private void HoverKey(string? key)
    {
        _hoveredKey = key;
    }

    private bool IsRelatedKey(string key)
    {
        if (string.IsNullOrEmpty(SelectedKey)) return false;

        // Find the index of selected key
        var selectedIndex = Array.IndexOf(MajorKeys, SelectedKey);
        if (selectedIndex < 0)
        {
            // Check if it's a minor key
            selectedIndex = Array.IndexOf(MinorKeys, SelectedKey);
            if (selectedIndex < 0) return false;
        }

        var keyIndex = Array.IndexOf(MajorKeys, key);
        if (keyIndex < 0) return false;

        // Related keys are adjacent on the circle (perfect fourth/fifth away)
        var diff = Math.Abs(selectedIndex - keyIndex);
        return diff == 1 || diff == 11; // Adjacent positions
    }

    private bool IsRelativeMinor(string minorKey)
    {
        if (string.IsNullOrEmpty(SelectedKey)) return false;

        // The relative minor is at the same position as its relative major
        var majorIndex = Array.IndexOf(MajorKeys, SelectedKey);
        if (majorIndex < 0) return false;

        var minorIndex = Array.IndexOf(MinorKeys, minorKey);
        return majorIndex == minorIndex;
    }

    private string GetArcPath(int index, double innerRadius, double outerRadius)
    {
        var startAngle = -90 + (index * 30) - 15;
        var endAngle = -90 + (index * 30) + 15;

        var startRadians = startAngle * Math.PI / 180;
        var endRadians = endAngle * Math.PI / 180;

        var x1 = 200 + innerRadius * Math.Cos(startRadians);
        var y1 = 200 + innerRadius * Math.Sin(startRadians);
        var x2 = 200 + outerRadius * Math.Cos(startRadians);
        var y2 = 200 + outerRadius * Math.Sin(startRadians);
        var x3 = 200 + outerRadius * Math.Cos(endRadians);
        var y3 = 200 + outerRadius * Math.Sin(endRadians);
        var x4 = 200 + innerRadius * Math.Cos(endRadians);
        var y4 = 200 + innerRadius * Math.Sin(endRadians);

        return $"M {x1:F2} {y1:F2} L {x2:F2} {y2:F2} A {outerRadius} {outerRadius} 0 0 1 {x3:F2} {y3:F2} L {x4:F2} {y4:F2} A {innerRadius} {innerRadius} 0 0 0 {x1:F2} {y1:F2} Z";
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        var allKeys = MajorKeys.Concat(MinorKeys).ToArray();

        switch (e.Key)
        {
            case "ArrowRight":
            case "ArrowDown":
                _focusedIndex = (_focusedIndex + 1) % allKeys.Length;
                await SelectKey(allKeys[_focusedIndex]);
                break;
            case "ArrowLeft":
            case "ArrowUp":
                _focusedIndex = (_focusedIndex - 1 + allKeys.Length) % allKeys.Length;
                await SelectKey(allKeys[_focusedIndex]);
                break;
            case "Enter":
            case " ":
                if (!string.IsNullOrEmpty(SelectedKey))
                {
                    var chord = ChordService.GetChord(SelectedKey);
                    if (chord != null)
                    {
                        await OnChordSelected.InvokeAsync(chord);
                    }
                }
                break;
            case "Escape":
                SelectedKey = null;
                await SelectedKeyChanged.InvokeAsync(null);
                break;
        }
    }
}
